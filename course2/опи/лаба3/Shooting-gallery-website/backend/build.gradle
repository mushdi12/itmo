import org.xml.sax.ErrorHandler
import java.security.MessageDigest
import javax.xml.parsers.DocumentBuilderFactory
import javax.xml.parsers.DocumentBuilder
import org.xml.sax.SAXException
import org.xml.sax.SAXParseException
import org.apache.tools.ant.taskdefs.condition.Os

plugins {
    id 'java'
    id 'war'
}

group = 'com.example'
version = '1.0-SNAPSHOT'

sourceCompatibility = '17'
targetCompatibility = '17'

configurations {
    antlibs
}

dependencies {
    implementation 'com.fasterxml.jackson.datatype:jackson-datatype-jsr310:2.16.1'
    providedCompile 'jakarta.platform:jakarta.jakartaee-api:11.0.0-M3'
    implementation 'jakarta.nosql:jakarta.nosql-api:1.0.0-M1'
    implementation 'org.glassfish.jersey.core:jersey-server:3.1.0'
    implementation 'org.glassfish.jersey.containers:jersey-container-servlet:3.1.0'
    implementation 'dev.morphia.morphia:morphia-core:2.3.7'
    implementation 'org.mongodb:mongodb-driver-sync:4.11.0'
    implementation 'com.auth0:java-jwt:4.4.0'
    implementation 'com.fasterxml.jackson.core:jackson-databind:2.16.1'
    implementation 'jakarta.security.enterprise:jakarta.security.enterprise-api:3.0.0'
    compileOnly 'org.projectlombok:lombok:1.18.28'
    annotationProcessor 'org.projectlombok:lombok:1.18.28'

    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.9.3'
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.9.3'

    testImplementation 'org.mockito:mockito-core:5.2.0'
    testImplementation 'org.mockito:mockito-inline:5.2.0'

    testCompileOnly 'org.projectlombok:lombok:1.18.28'
    testAnnotationProcessor 'org.projectlombok:lombok:1.18.28'

    antlibs  'org.apache.ant:ant:1.10.12'

    testImplementation 'org.seleniumhq.selenium:selenium-java:4.11.0'
    testImplementation 'org.junit.jupiter:junit-jupiter:5.10.0'
}


repositories {
    mavenCentral()
}

//javadoc {
//    options.addStringOption('Xdoclint:none', '-quiet')
//}

javadoc {
    options.optionFiles.add(file("javadoc.options"))
}


war {
    archiveBaseName = 'backend'
    archiveVersion = '1.0-SNAPSHOT'
    destinationDirectory = file("$buildDir/libs")
}

ext {
    wildflyDeployPath = '/home/mushdi12/itmo/opi/lab3/wildfly-31.0.1.Final/standalone/deployments'
    wildflyBin = '/home/mushdi12/itmo/opi/lab3/wildfly-31.0.1.Final/bin'
}

def isBuildSuccessful = { -> gradle.taskGraph.allTasks.find { it.state.failure != null } == null
}

def hashFile(File file, String algorithm) {
    MessageDigest digest = MessageDigest.getInstance(algorithm)
    file.withInputStream { is ->
        byte[] buffer = new byte[8192]
        int read
        while ((read = is.read(buffer)) != -1) {
            digest.update(buffer, 0, read)
        }
    }
    return digest.digest().encodeHex().toString()
}

// сценарий 1 "compile" - компиляция исходного кода 
task compile {
    group = 'build'
    dependsOn 'compileJava'
}

// сценарий 2 "build" -> компиляция исходных кодов + упаковка в war 
build {
    dependsOn test
}

// сценарий 3 "clean" -> удаление скомпилированных классов проекта 
tasks.named('clean') {
    group = 'build'
}

// сценарий 4 "test" -> запуск junit-тестов проекта 
test {
    useJUnitPlatform()
}

// сценарий 5 "doc" -> добавление в MANIFEST.MF MD5 и SHA-1 файлов проекта 
task doc(type: Jar) {
    dependsOn javadoc, war
    archiveClassifier = 'doc'

    from javadoc.destinationDir

    doFirst {
        def warFile = war.archiveFile.get().asFile
        def md5 = hashFile(warFile, "MD5")
        def sha1 = hashFile(warFile, "SHA-1")

        manifest {
            attributes(
                    "Implementation-Title": project.name,
                    "Implementation-Version": project.version,
                    "MD5-Checksum": md5,
                    "SHA1-Checksum": sha1
            )
        }
    }
}

// сценарий 6 "xml" -> валидация всех xml-файлов в проекте 
task xml {
    group = 'verification'

    doLast {
        def xmlFiles = fileTree(projectDir) {
            include '**/*.xml'
        }

        def factory = DocumentBuilderFactory.newInstance()
        factory.setValidating(false)
        factory.setNamespaceAware(true)

        int errorCount = 0

        xmlFiles.each { File xmlFile ->
            try {
                DocumentBuilder builder = factory.newDocumentBuilder()
                builder.setErrorHandler([
                        warning   : { SAXParseException e -> println "Warning in ${xmlFile}: ${e.message}" },
                        error     : { SAXParseException e -> throw e },
                        fatalError: { SAXParseException e -> throw e }
                ] as ErrorHandler)

                builder.parse(xmlFile)
                println "Valid: ${xmlFile}"
            } catch (SAXParseException e) {
                println "Invalid XML: ${xmlFile} (${e.lineNumber}:${e.columnNumber}) — ${e.message}"
                errorCount++
            } catch (SAXException | IOException e) {
                println "Error parsing ${xmlFile}: ${e.message}"
                errorCount++
            }
        }

        if (errorCount > 0) {
            println "Найдено $errorCount XML-файлов с ошибками."
        } else {
            println " Все XML-файлы валидны."
        }
    }
}

// сценарий 7 "scp " -> перемещение собранного проекта по scp se.ifmo.ru 
// Перед запуском нужно ввести: eval "$(ssh-agent -s)" и ssh-add ~/.ssh/id_rsa
task scp(type: Exec) {
    group = 'deployment'

    dependsOn build

    def warFile = war.archiveFile.get().asFile
    def remoteUser = 's408319'
    def remoteHost = 'se.ifmo.ru'
    def remotePort = '2222'
    def remoteDir = '/home/studs/s408319/opi'

    dependsOn war

    doFirst {
        println "Отправка ${warFile} на ${remoteUser}@${remoteHost}:${remoteDir}"
    }

    commandLine 'scp', '-P', remotePort, warFile.toString(), "${remoteUser}@${remoteHost}:${remoteDir}"
}

// сценарий 8 "native2ascii" -> преобразование native2ascii для копий файлов локализации 
task native2ascii {
    doLast {
        def inputFile = file('src/main/resources/messages_ru.properties')
        def outputFile = file('build/native2ascii/messages_ru_ascii.properties')
        outputFile.parentFile.mkdirs()

        outputFile.withWriter('UTF-8') { writer ->
            inputFile.eachLine('UTF-8') { line ->
                def converted = line.collect { c ->
                    (c as char) as int > 127 ? "\\u" + Integer.toHexString((c as char) as int).padLeft(4, '0') : c
                }.join()
                writer.writeLine(converted)
            }
        }
        println "Конвертация завершена: $outputFile"
    }
}

// сценарий 9 "music" -> воспроизведение музыки по завершению сборки 
task music {
    group = 'notification'

    doLast {
        if (!isBuildSuccessful()) {
            println "Сборка завершилась с ошибками — музыка не проигрывается."
            return
        }

        def filePath = "success.mp3"
        if (!file(filePath).exists()) {
            println "Файл музыки $filePath не найден."
            return
        }

        def osName = System.getProperty("os.name").toLowerCase()
        def command = null

        if (osName.contains("mac")) {
            command = ['afplay', filePath]
        } else {
            def hasMpg123 = "which mpg123".execute().text.trim()
            def hasFfplay = "which ffplay".execute().text.trim()

            if (hasMpg123) {
                command = ['mpg123', '-q', filePath]
            } else if (hasFfplay) {
                command = ['ffplay', '-nodisp', '-autoexit', '-loglevel', 'quiet', filePath]
            } else {
                println "Не найден mpg123 или ffplay — музыку не воспроизводим."
                return
            }
        }

        try {
            def process = command.execute()
            process.consumeProcessOutput(new ByteArrayOutputStream(), new ByteArrayOutputStream()) // без вывода
            process.waitFor()
            if (process.exitValue() != 0) {
                println "Ошибка воспроизведения музыки."
            }
        } catch (Exception e) {
            println "Не удалось воспроизвести музыку: ${e.message}"
        }
    }
}

// сценарий 10 "alt" -> создаёт альтернативную версию программы 
task alt(dependsOn: build) {

    doLast {
        println "Распаковка оригинального WAR..."

        def originalWar = file("${buildDir}/libs/${project.name}-${project.version}.war")
        def altWar = file("${buildDir}/libs/${project.name}-${project.version}-alt.war")
        def tempDir = file("${buildDir}/alt-tmp")

        delete tempDir
        copy {
            from zipTree(originalWar)
            into tempDir
        }

        def replacements = [
                'PointService'  : 'AltPointService',
                'AIPointService': 'AltAIPointService',
                'UserServiceEJB': 'AltUserServiceEJB',
                'CORSFilter'    : 'AltCORSFilter'
        ]

        fileTree(tempDir).include('**/*.class').each { classFile ->
            try {
                def newClassName = classFile.name
                replacements.each { oldName, newName ->
                    newClassName = newClassName.replace(oldName, newName)
                }

                if (newClassName != classFile.name) {
                    def newFile = new File(classFile.parent, newClassName)
                    classFile.renameTo(newFile)
                }
            } catch (Exception e) {
                println "Ошибка обработки ${classFile.name}: ${e.message}"
            }
        }
        fileTree(tempDir).include('**/*.xml').each { xmlFile ->
            try {
                def content = xmlFile.getText('UTF-8')
                replacements.each { oldName, newName ->
                    content = content.replace(oldName, newName)
                }
                xmlFile.setText(content, 'UTF-8')
            } catch (Exception e) {
                println "Ошибка обработки ${xmlFile.name}: ${e.message}"
            }
        }

        ant.zip(destfile: altWar) {
            fileset(dir: tempDir)
        }

        println "Альтернативный WAR создан: ${altWar}"
    }
}

// сценарий 11 "report" -> в случае успешного прохождения тестов сохраняет отчет junit в формате xml 
task report {
    group = 'verification'

    dependsOn test

    doLast {
        if (test.state.failure != null) {
            println "Тесты не прошли, отчет не будет закоммичен."
            return
        }

        def reportDir = file("${buildDir}/test-results/test")
        if (!reportDir.exists()) {
            println "Отчеты JUnit не найдены в ${reportDir}"
            return
        }

        def xmlFiles = fileTree(reportDir) {
            include '**/*.xml'
        }.files

        if (xmlFiles.isEmpty()) {
            println "Не найдено xml-файлов для добавления."
            return
        }


        xmlFiles.each { file ->
            def relativePath = file.absolutePath - project.rootDir.absolutePath
            if (relativePath.startsWith(File.separator)) {
                relativePath = relativePath.substring(1)
            }

            exec {
                commandLine 'git', 'add', relativePath
            }
        }
        def commitMessage = "Add JUnit test report - ${new Date().format('yyyy-MM-dd HH:mm:ss')}"
        def commitResult = exec {
            commandLine 'git', 'commit', '-m', commitMessage
            ignoreExitValue true
        }

        println "Отчеты JUnit добавлены и коммичены (если были изменения)."
    }
}

// сценарий 12 "team" -> осуществляет получение из git-репозитория 2 предыдущих ревизий, их сборку 
task team {
    group = 'build'

    def gitRootDir = '/home/mushdi12/itmo/opi/lab3/Shooting-gallery-website/backend'

    def buildDirBase = "${buildDir}/team"
    def zipFile = file("${buildDir}/libs/previous_revisions.zip")

    doLast {
        def revs = "git -C ${gitRootDir} rev-list --max-count=3 HEAD".execute().text.readLines()
        if (revs.size() < 3) {
            println ("В репозитории меньше 3 коммитов для сборки")
        }
        def prevRevs = revs[1..2]

        delete(buildDirBase)
        mkdir(buildDirBase)

        prevRevs.each { rev ->
            println "Собираем ревизию $rev"


            def revDir = file("${buildDirBase}/${rev}")
            revDir.mkdirs()

            def cloneCmd = "git clone ${gitRootDir} ${revDir}".execute()
            cloneCmd.waitFor()
            if (cloneCmd.exitValue() != 0) {
                println ("Ошибка клонирования репозитория для ревизии $rev")
            }

            def checkoutCmd = "git -C ${revDir} checkout $rev".execute()
            checkoutCmd.waitFor()
            if (checkoutCmd.exitValue() != 0) {
                println ("Ошибка checkout для ревизии $rev")
            }

            def buildCmd = "./gradlew -p ${revDir} clean build"
            println "Выполняем: $buildCmd"
            def proc = buildCmd.execute()
            proc.in.eachLine { println it }
            proc.err.eachLine { System.err.println it }
            proc.waitFor()
            if (proc.exitValue() != 0) {
                println ("Ошибка сборки ревизии $rev")
            }
        }

        ant.zip(destfile: zipFile) {
            prevRevs.each { rev ->
                fileset(dir: "${buildDirBase}/${rev}/build/libs") {
                    include(name: "*.war")
                }
            }
        }

        println "Готов zip с предыдущими ревизиями: $zipFile"
    }
}

// сценарий 13 "diff" -> осуществляет проверку состояния рабочей копии, и,
// если изменения касаются классов, указанных в файле параметров выполняет commit в репозиторий git. 
task diff {
    doLast {
        def trackedFiles = [
                'src/main/java/com/example/backend/auth',
                'src/main/java/com/example/backend/points',
                'src/main/java/com/example/backend/utils',
                'src/main/java/com/example/backend/webApp',
        ]

        def filesToCommit = []

        trackedFiles.each { trackedFilePath ->
            def file = new File(project.rootDir, trackedFilePath)

            if (!file.exists()) {
                println "Файл $trackedFilePath не существует, пропускаем."
                return
            }

            def stdout = new ByteArrayOutputStream()
            exec {
                workingDir = project.rootDir
                commandLine 'git', 'diff', '--name-only', '--', trackedFilePath
                standardOutput = stdout
            }

            def changedFiles = stdout.toString().readLines()
                    .collect { it.trim() }
                    .findAll { it }

            if (changedFiles.isEmpty()) {
                println "Изменений в файле $trackedFilePath нет."
            } else {
                println "Файл для коммита: $trackedFilePath"
                filesToCommit << trackedFilePath
            }
        }

        if (filesToCommit.isEmpty()) {
            println "Изменений для коммита нет."
            return
        }

        exec {
            workingDir = project.rootDir
            commandLine 'git', 'add', *filesToCommit
        }

        exec {
            workingDir = project.rootDir
            commandLine 'git', 'commit', '-m', "Автоматический коммит изменений файлов: ${filesToCommit.join(', ')}"
        }
    }
}

// сценарий 14 "env" -> осуществляет сборку и запуск программы в альтернативных окружениях
// sudo lsof -i :8080
task env(type: Exec, dependsOn: 'deploy') {
    group = 'custom'

    doFirst {
        def propsFile = file('env.properties')
        if (!propsFile.exists()) {
            throw new GradleException("Нет файла env.properties")
        }

        def props = new Properties()
        propsFile.withInputStream { props.load(it) }

        def javaHomeENV = props.getProperty('javaHomeENV')
        def wildflyDeployPathENV = props.getProperty('wildflyDeployPathENV')
        def wildflyBinENV = props.getProperty('wildflyBinENV')

        if (!javaHomeENV || !wildflyDeployPathENV || !wildflyBinENV) {
            throw new GradleException("Нужно указать javaHomeENV, wildflyDeployPathENV и wildflyBinENV в env.properties")
        }

        environment 'JAVA_HOME', javaHomeENV
        workingDir = file(wildflyBinENV)
        commandLine "${wildflyBinENV}/standalone.sh"
    }
}

// сценарий 15 "history" ->  если проект не удаётся скомпилировать (цель compile), загружается предыдущая версия из репозитория 
task history {
    group = 'custom'

    doLast {
        def tryCompile = {
            def process = "./gradlew compileJava".execute()
            process.consumeProcessOutput(System.out, System.err)
            return process.waitFor() == 0
        }

        println "Пробуем собрать текущую версию (HEAD)..."
        if (tryCompile()) {
            println "Текущий коммит успешно собирается. Откат не требуется."
            return
        }

        println "Сборка текущей версии не удалась. Ищем последнюю рабочую ревизию..."

        def commitList = "git rev-list HEAD".execute().text.readLines()
        if (commitList.isEmpty()) {
            throw new GradleException("Ревизии не найдены")
        }

        String lastWorkingCommit = null
        String failedCommit = null

        for (int i = 1; i < commitList.size(); i++) {
            String commit = commitList[i]
            println "Пробуем коммит: $commit"

            def checkout = "git checkout $commit".execute()
            checkout.waitFor()

            if (tryCompile()) {
                lastWorkingCommit = commit
                failedCommit = commitList[i - 1]
                break
            }
        }

        if (!lastWorkingCommit) {
            throw new GradleException("Не найдено ни одной рабочей ревизии")
        }

        println "Последняя рабочая ревизия: $lastWorkingCommit"
        println "Следующая после неё (с ошибкой): $failedCommit"

        if (failedCommit) {
            def diffCmd = "git diff $lastWorkingCommit $failedCommit".execute()
            def diffText = new StringBuffer()
            diffCmd.consumeProcessOutput(diffText, System.err)
            diffCmd.waitFor()

            def diffFile = file("history-diff.txt")
            diffFile.text = diffText.toString()
            println "Diff сохранён в history-diff.txt"
        }

        "git checkout $lastWorkingCommit".execute().waitFor()
    }
}

// сам сделал для удобства
task deploy(type: Copy) {
    dependsOn 'build'
    from war.archiveFile.get().asFile
    into wildflyDeployPath
    rename { 'backend.war' }
}

task run(type: Exec) {
    workingDir = file(wildflyBin)
    commandLine 'bash', 'standalone.sh'
}
