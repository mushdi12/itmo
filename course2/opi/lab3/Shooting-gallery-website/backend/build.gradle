import org.xml.sax.ErrorHandler
import java.security.MessageDigest
import javax.xml.parsers.DocumentBuilderFactory
import javax.xml.parsers.DocumentBuilder
import org.xml.sax.SAXException
import org.xml.sax.SAXParseException
import org.apache.tools.ant.taskdefs.condition.Os

plugins {
    id 'java'
    id 'war'
}

group = 'com.example'
version = '1.0-SNAPSHOT'

sourceCompatibility = '17'
targetCompatibility = '17'

configurations {
    antlibs
}

dependencies {
    implementation 'com.fasterxml.jackson.datatype:jackson-datatype-jsr310:2.16.1'
    providedCompile 'jakarta.platform:jakarta.jakartaee-api:11.0.0-M3'
    implementation 'jakarta.nosql:jakarta.nosql-api:1.0.0-M1'
    implementation 'org.glassfish.jersey.core:jersey-server:3.1.0'
    implementation 'org.glassfish.jersey.containers:jersey-container-servlet:3.1.0'
    implementation 'dev.morphia.morphia:morphia-core:2.3.7'
    implementation 'org.mongodb:mongodb-driver-sync:4.11.0'
    implementation 'com.auth0:java-jwt:4.4.0'
    implementation 'com.fasterxml.jackson.core:jackson-databind:2.16.1'
    implementation 'jakarta.security.enterprise:jakarta.security.enterprise-api:3.0.0'
    compileOnly 'org.projectlombok:lombok:1.18.28'
    annotationProcessor 'org.projectlombok:lombok:1.18.28'

    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.9.3'
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.9.3'

    testImplementation 'org.mockito:mockito-core:5.2.0'
    testImplementation 'org.mockito:mockito-inline:5.2.0'

    testCompileOnly 'org.projectlombok:lombok:1.18.28'
    testAnnotationProcessor 'org.projectlombok:lombok:1.18.28'

    antlibs  'org.apache.ant:ant:1.10.12'

    testImplementation 'org.seleniumhq.selenium:selenium-java:4.11.0'
    testImplementation 'org.junit.jupiter:junit-jupiter:5.10.0'
}


repositories {
    mavenCentral()
}

//javadoc {
//    options.addStringOption('Xdoclint:none', '-quiet')
//}

javadoc {
    options.optionFiles.add(file("javadoc.options"))
}


war {
    archiveBaseName = 'backend'
    archiveVersion = '1.0-SNAPSHOT'
    destinationDirectory = file("$buildDir/libs")
}

ext {
    wildflyDeployPath = '/home/mushdi12/itmo/course2/opi/lab3/wildfly-31.0.1.Final/standalone/deployments'
    wildflyBin = '/home/mushdi12/itmo/course2/opi/lab3/wildfly-31.0.1.Final/bin'
}

//def isBuildSuccessful = { -> gradle.taskGraph.allTasks.find { it.state.failure != null } == null
//}
//
//def hashFile(File file, String algorithm) {
//    MessageDigest digest = MessageDigest.getInstance(algorithm)
//    file.withInputStream { is ->
//        byte[] buffer = new byte[8192]
//        int read
//        while ((read = is.read(buffer)) != -1) {
//            digest.update(buffer, 0, read)
//        }
//    }
//    return digest.digest().encodeHex().toString()
//}

// сценарий 1 "compile" - компиляция исходного кода 

// сценарий 4 "test" -> запуск junit-тестов проекта
//test {
//    useJUnitPlatform()
//}
//
//// сценарий 5 "doc" -> добавление в MANIFEST.MF MD5 и SHA-1 файлов проекта
//task doc(type: Jar) {
//    dependsOn javadoc, war
//    archiveClassifier = 'doc'
//
//    from javadoc.destinationDir
//
//    doFirst {
//        def warFile = war.archiveFile.get().asFile
//        def md5 = hashFile(warFile, "MD5")
//        def sha1 = hashFile(warFile, "SHA-1")
//
//        manifest {
//            attributes(
//                    "Implementation-Title": project.name,
//                    "Implementation-Version": project.version,
//                    "MD5-Checksum": md5,
//                    "SHA1-Checksum": sha1
//            )
//        }
//    }
//}
//
//// сценарий 6 "xml" -> валидация всех xml-файлов в проекте
//task xml {
//    group = 'verification'
//
//    doLast {
//        def xmlFiles = fileTree(projectDir) {
//            include '**/*.xml'
//        }
//
//        def factory = DocumentBuilderFactory.newInstance()
//        factory.setValidating(false)
//        factory.setNamespaceAware(true)
//
//        int errorCount = 0
//
//        xmlFiles.each { File xmlFile ->
//            try {
//                DocumentBuilder builder = factory.newDocumentBuilder()
//                builder.setErrorHandler([
//                        warning   : { SAXParseException e -> println "Warning in ${xmlFile}: ${e.message}" },
//                        error     : { SAXParseException e -> throw e },
//                        fatalError: { SAXParseException e -> throw e }
//                ] as ErrorHandler)
//
//                builder.parse(xmlFile)
//                println "Valid: ${xmlFile}"
//            } catch (SAXParseException e) {
//                println "Invalid XML: ${xmlFile} (${e.lineNumber}:${e.columnNumber}) — ${e.message}"
//                errorCount++
//            } catch (SAXException | IOException e) {
//                println "Error parsing ${xmlFile}: ${e.message}"
//                errorCount++
//            }
//        }
//
//        if (errorCount > 0) {
//            println "Найдено $errorCount XML-файлов с ошибками."
//        } else {
//            println " Все XML-файлы валидны."
//        }
//    }
//}
//
//// сценарий 7 "scp " -> перемещение собранного проекта по scp se.ifmo.ru
//// Перед запуском нужно ввести: eval "$(ssh-agent -s)" и ssh-add ~/.ssh/id_rsa
//task scp(type: Exec) {
//    group = 'deployment'
//
//    dependsOn build
//
//    def warFile = war.archiveFile.get().asFile
//    def remoteUser = 's408319'
//    def remoteHost = 'se.ifmo.ru'
//    def remotePort = '2222'
//    def remoteDir = '/home/studs/s408319/opi'
//
//    dependsOn war
//
//    doFirst {
//        println "Отправка ${warFile} на ${remoteUser}@${remoteHost}:${remoteDir}"
//    }
//
//    commandLine 'scp', '-P', remotePort, warFile.toString(), "${remoteUser}@${remoteHost}:${remoteDir}"
//}
//
//// сценарий 8 "native2ascii" -> преобразование native2ascii для копий файлов локализации
//task native2ascii {
//    doLast {
//        def inputFile = file('src/main/resources/messages_ru.properties')
//        def outputFile = file('build/native2ascii/messages_ru_ascii.properties')
//        outputFile.parentFile.mkdirs()
//
//        outputFile.withWriter('UTF-8') { writer ->
//            inputFile.eachLine('UTF-8') { line ->
//                def converted = line.collect { c ->
//                    (c as char) as int > 127 ? "\\u" + Integer.toHexString((c as char) as int).padLeft(4, '0') : c
//                }.join()
//                writer.writeLine(converted)
//            }
//        }
//        println "Конвертация завершена: $outputFile"
//    }
//}
//
//// сценарий 9 "music" -> воспроизведение музыки по завершению сборки
//task music {
//    group = 'notification'
//
//    doLast {
//        if (!isBuildSuccessful()) {
//            println "Сборка завершилась с ошибками — музыка не проигрывается."
//            return
//        }
//
//        def filePath = "success.mp3"
//        if (!file(filePath).exists()) {
//            println "Файл музыки $filePath не найден."
//            return
//        }
//
//        def osName = System.getProperty("os.name").toLowerCase()
//        def command = null
//
//        if (osName.contains("mac")) {
//            command = ['afplay', filePath]
//        } else {
//            def hasMpg123 = "which mpg123".execute().text.trim()
//            def hasFfplay = "which ffplay".execute().text.trim()
//
//            if (hasMpg123) {
//                command = ['mpg123', '-q', filePath]
//            } else if (hasFfplay) {
//                command = ['ffplay', '-nodisp', '-autoexit', '-loglevel', 'quiet', filePath]
//            } else {
//                println "Не найден mpg123 или ffplay — музыку не воспроизводим."
//                return
//            }
//        }
//
//        try {
//            def process = command.execute()
//            process.consumeProcessOutput(new ByteArrayOutputStream(), new ByteArrayOutputStream()) // без вывода
//            process.waitFor()
//            if (process.exitValue() != 0) {
//                println "Ошибка воспроизведения музыки."
//            }
//        } catch (Exception e) {
//            println "Не удалось воспроизвести музыку: ${e.message}"
//        }
//    }
//}
//
//// сценарий 10 "alt" -> создаёт альтернативную версию программы
//task alt(dependsOn: build) {
//
//    doLast {
//        println "Распаковка оригинального WAR..."
//
//        def originalWar = file("${buildDir}/libs/${project.name}-${project.version}.war")
//        def altWar = file("${buildDir}/libs/${project.name}-${project.version}-alt.war")
//        def tempDir = file("${buildDir}/alt-tmp")
//
//        delete tempDir
//        copy {
//            from zipTree(originalWar)
//            into tempDir
//        }
//
//        def replacements = [
//                'PointService'  : 'AltPointService',
//                'AIPointService': 'AltAIPointService',
//                'UserServiceEJB': 'AltUserServiceEJB',
//                'CORSFilter'    : 'AltCORSFilter'
//        ]
//
//        fileTree(tempDir).include('**/*.class').each { classFile ->
//            try {
//                def newClassName = classFile.name
//                replacements.each { oldName, newName ->
//                    newClassName = newClassName.replace(oldName, newName)
//                }
//
//                if (newClassName != classFile.name) {
//                    def newFile = new File(classFile.parent, newClassName)
//                    classFile.renameTo(newFile)
//                }
//            } catch (Exception e) {
//                println "Ошибка обработки ${classFile.name}: ${e.message}"
//            }
//        }
//        fileTree(tempDir).include('**/*.xml').each { xmlFile ->
//            try {
//                def content = xmlFile.getText('UTF-8')
//                replacements.each { oldName, newName ->
//                    content = content.replace(oldName, newName)
//                }
//                xmlFile.setText(content, 'UTF-8')
//            } catch (Exception e) {
//                println "Ошибка обработки ${xmlFile.name}: ${e.message}"
//            }
//        }
//
//        ant.zip(destfile: altWar) {
//            fileset(dir: tempDir)
//        }
//
//        println "Альтернативный WAR создан: ${altWar}"
//    }
//}
//
//// сценарий 11 "report" -> в случае успешного прохождения тестов сохраняет отчет junit в формате xml
//task report {
//    group = 'verification'
//
//    dependsOn test
//
//    doLast {
//        if (test.state.failure != null) {
//            println "Тесты не прошли, отчет не будет закоммичен."
//            return
//        }
//
//        def reportDir = file("${buildDir}/test-results/test")
//        if (!reportDir.exists()) {
//            println "Отчеты JUnit не найдены в ${reportDir}"
//            return
//        }
//
//        def xmlFiles = fileTree(reportDir) {
//            include '**/*.xml'
//        }.files
//
//        if (xmlFiles.isEmpty()) {
//            println "Не найдено xml-файлов для добавления."
//            return
//        }
//
//
//        xmlFiles.each { file ->
//            def relativePath = file.absolutePath - project.rootDir.absolutePath
//            if (relativePath.startsWith(File.separator)) {
//                relativePath = relativePath.substring(1)
//            }
//
//            exec {
//                commandLine 'git', 'add', relativePath
//            }
//        }
//        def commitMessage = "Add JUnit test report - ${new Date().format('yyyy-MM-dd HH:mm:ss')}"
//        def commitResult = exec {
//            commandLine 'git', 'commit', '-m', commitMessage
//            ignoreExitValue true
//        }
//
//        println "Отчеты JUnit добавлены и коммичены (если были изменения)."
//    }
//}
//
//// сценарий 12 "team" -> осуществляет получение из git-репозитория 2 предыдущих ревизий, их сборку
//task team {
//    group = 'build'
//
//    def gitRootDir = '/home/mushdi12/itmo/opi/lab3/Shooting-gallery-website/backend'
//
//    def buildDirBase = "${buildDir}/team"
//    def zipFile = file("${buildDir}/libs/previous_revisions.zip")
//
//    doLast {
//        def revs = "git -C ${gitRootDir} rev-list --max-count=3 HEAD".execute().text.readLines()
//        if (revs.size() < 3) {
//            println ("В репозитории меньше 3 коммитов для сборки")
//        }
//        def prevRevs = revs[1..2]
//
//        delete(buildDirBase)
//        mkdir(buildDirBase)
//
//        prevRevs.each { rev ->
//            println "Собираем ревизию $rev"
//
//
//            def revDir = file("${buildDirBase}/${rev}")
//            revDir.mkdirs()
//
//            def cloneCmd = "git clone ${gitRootDir} ${revDir}".execute()
//            cloneCmd.waitFor()
//            if (cloneCmd.exitValue() != 0) {
//                println ("Ошибка клонирования репозитория для ревизии $rev")
//            }
//
//            def checkoutCmd = "git -C ${revDir} checkout $rev".execute()
//            checkoutCmd.waitFor()
//            if (checkoutCmd.exitValue() != 0) {
//                println ("Ошибка checkout для ревизии $rev")
//            }
//
//            def buildCmd = "./gradlew -p ${revDir} clean build"
//            println "Выполняем: $buildCmd"
//            def proc = buildCmd.execute()
//            proc.in.eachLine { println it }
//            proc.err.eachLine { System.err.println it }
//            proc.waitFor()
//            if (proc.exitValue() != 0) {
//                println ("Ошибка сборки ревизии $rev")
//            }
//        }
//
//        ant.zip(destfile: zipFile) {
//            prevRevs.each { rev ->
//                fileset(dir: "${buildDirBase}/${rev}/build/libs") {
//                    include(name: "*.war")
//                }
//            }
//        }
//
//        println "Готов zip с предыдущими ревизиями: $zipFile"
//    }
//}
//
//// сценарий 13 "diff" -> осуществляет проверку состояния рабочей копии, и,
//// если изменения касаются классов, указанных в файле параметров выполняет commit в репозиторий git.
//task diff {
//    doLast {
//        def trackedFiles = [
//                'src/main/java/com/example/backend/auth',
//                'src/main/java/com/example/backend/points',
//                'src/main/java/com/example/backend/utils',
//                'src/main/java/com/example/backend/webApp',
//        ]
//
//        def filesToCommit = []
//
//        trackedFiles.each { trackedFilePath ->
//            def file = new File(project.rootDir, trackedFilePath)
//
//            if (!file.exists()) {
//                println "Файл $trackedFilePath не существует, пропускаем."
//                return
//            }
//
//            def stdout = new ByteArrayOutputStream()
//            exec {
//                workingDir = project.rootDir
//                commandLine 'git', 'diff', '--name-only', '--', trackedFilePath
//                standardOutput = stdout
//            }
//
//            def changedFiles = stdout.toString().readLines()
//                    .collect { it.trim() }
//                    .findAll { it }
//
//            if (changedFiles.isEmpty()) {
//                println "Изменений в файле $trackedFilePath нет."
//            } else {
//                println "Файл для коммита: $trackedFilePath"
//                filesToCommit << trackedFilePath
//            }
//        }
//
//        if (filesToCommit.isEmpty()) {
//            println "Изменений для коммита нет."
//            return
//        }
//
//        exec {
//            workingDir = project.rootDir
//            commandLine 'git', 'add', *filesToCommit
//        }
//
//        exec {
//            workingDir = project.rootDir
//            commandLine 'git', 'commit', '-m', "Автоматический коммит изменений файлов: ${filesToCommit.join(', ')}"
//        }
//    }
//}
//
//// сценарий 14 "env" -> осуществляет сборку и запуск программы в альтернативных окружениях
//// sudo lsof -i :8080
//task env(type: Exec, dependsOn: 'deploy') {
//    group = 'custom'
//
//    doFirst {
//        def propsFile = file('env.properties')
//        if (!propsFile.exists()) {
//            throw new GradleException("Нет файла env.properties")
//        }
//
//        def props = new Properties()
//        propsFile.withInputStream { props.load(it) }
//
//        def javaHomeENV = props.getProperty('javaHomeENV')
//        def wildflyDeployPathENV = props.getProperty('wildflyDeployPathENV')
//        def wildflyBinENV = props.getProperty('wildflyBinENV')
//
//
//        if (!javaHomeENV || !wildflyDeployPathENV || !wildflyBinENV) {
//            throw new GradleException("Нужно указать javaHomeENV, wildflyDeployPathENV и wildflyBinENV в env.properties")
//        }
//
//        environment 'JAVA_HOME', javaHomeENV
//        workingDir = file(wildflyBinENV)
//        commandLine "${wildflyBinENV}/standalone.sh"
//    }
//}
//
//// сценарий 15 "history" ->  если проект не удаётся скомпилировать (цель compile), загружается предыдущая версия из репозитория
//task history {
//    group = 'custom'
//
//    doLast {
//        def tryCompile = {
//            def process = "./gradlew compileJava".execute()
//            process.consumeProcessOutput(System.out, System.err)
//            return process.waitFor() == 0
//        }
//
//        println "Пробуем собрать текущую версию (HEAD)..."
//        if (tryCompile()) {
//            println "Текущий коммит успешно собирается. Откат не требуется."
//            return
//        }
//
//        println "Сборка текущей версии не удалась. Ищем последнюю рабочую ревизию..."
//
//        def commitList = "git rev-list HEAD".execute().text.readLines()
//        if (commitList.isEmpty()) {
//            throw new GradleException("Ревизии не найдены")
//        }
//
//        String lastWorkingCommit = null
//        String failedCommit = null
//
//        for (int i = 1; i < commitList.size(); i++) {
//            String commit = commitList[i]
//            println "Пробуем коммит: $commit"
//
//            def checkout = "git checkout $commit".execute()
//            checkout.waitFor()
//
//            if (tryCompile()) {
//                lastWorkingCommit = commit
//                failedCommit = commitList[i - 1]
//                break
//            }
//        }
//
//        if (!lastWorkingCommit) {
//            throw new GradleException("Не найдено ни одной рабочей ревизии")
//        }
//
//        println "Последняя рабочая ревизия: $lastWorkingCommit"
//        println "Следующая после неё (с ошибкой): $failedCommit"
//
//        if (failedCommit) {
//            def diffCmd = "git diff $lastWorkingCommit $failedCommit".execute()
//            def diffText = new StringBuffer()
//            diffCmd.consumeProcessOutput(diffText, System.err)
//            diffCmd.waitFor()
//
//            def diffFile = file("history-diff.txt")
//            diffFile.text = diffText.toString()
//            println "Diff сохранён в history-diff.txt"
//        }
//
//        "git checkout $lastWorkingCommit".execute().waitFor()
//    }
//}

// сам сделал для удобства

task compile {
    group = 'build'
    dependsOn 'compileJava'
}

// сценарий 2 "build" -> компиляция исходных кодов + упаковка в war
tasks.named('build') {
    dependsOn test
}


task deploy(type: Copy) {
    dependsOn 'build'
    from war.archiveFile.get().asFile
    into wildflyDeployPath
}

task run(type: Exec) {
    dependsOn 'deploy'
    workingDir = file(wildflyBin)
    commandLine 'bash', 'standalone.sh'
}

task fullDeploy {
    group = 'application'
    description = 'Полный цикл: очистка, сборка, деплой и запуск WildFly'

    dependsOn  'deploy', 'run'
}
